This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.gitignore
app.py
Dockerfile
main.py
paises.csv
README.md
requirements.txt
templates/index.html
utils/buscar_pais.py
utils/carga_datos.py
utils/estadisticas.py
utils/filtro_continente.py
utils/filtro_rango_poblacion.py
utils/filtro_rango_superficie.py
utils/menu.py
utils/ordenar_paises.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
# .dockerignore

# Git
.git
.gitignore

# Docker
Dockerfile
.dockerignore

# Entornos virtuales de Python
.venv
venv/
env/

# Caché de Python
__pycache__/
*.pyc

# Archivos de configuración de IDEs
.vscode/
.idea/
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/
</file>

<file path="app.py">
from flask import Flask, render_template
from utils.carga_datos import cargar_paises_desde_csv 

# 1. Creamos la aplicación Flask
app = Flask(__name__)

# 2. Cargamos los datos UNA SOLA VEZ cuando la app inicia
lista_de_paises = cargar_paises_desde_csv('paises.csv')

# 3. Definimos una "ruta" (una URL)
# El decorador @app.route('/') significa "cuando alguien visite la página principal..."
@app.route('/')
def inicio():
    """
    Esta función se ejecuta cuando se accede a la URL principal.
    """
    return render_template('index.html', paises=lista_de_paises)

# Esto es para poder ejecutarlo directamente con 'python app.py' para pruebas
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
</file>

<file path="Dockerfile">
FROM python:3.11-slim

# Establecemos el directorio de trabajo.
WORKDIR /app

# Primero, copiamos SOLO el archivo de requerimientos.
COPY requirements.txt .

# Luego, instalamos las dependencias. Docker guardará en caché esta capa.
# Si no cambiamos requirements.txt, este paso no se volverá a ejecutar,
# haciendo las futuras construcciones (builds) mucho más rápidas.
RUN pip install --no-cache-dir -r requirements.txt


# Ahora que las dependencias están instaladas, copiamos el resto del código.
COPY . .

# Le informamos a Docker que el contenedor escuchará en el puerto 5000.
# Esto es más bien una documentación, el mapeo real se hace en 'docker run'.
EXPOSE 5000


# Ejecutamos la aplicación web usando el archivo app.py.
CMD ["python", "app.py"]
</file>

<file path="requirements.txt">
Flask
</file>

<file path="templates/index.html">
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Datos de Países</title>
    <style>
        body { font-family: sans-serif; margin: 2em; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #dddddd; text-align: left; padding: 8px; }
        thead { background-color: #f2f2f2; }
    </style>
</head>
<body>

    <h1>Listado de Países del Mundo</h1>
    <p>Datos cargados desde Python y Flask.</p>

    <table>
        <thead>
            <tr>
                <th>Nombre</th>
                <th>Continente</th>
                <th>Población</th>
                <th>Superficie (km²)</th>
            </tr>
        </thead>
        <tbody>
            {% for pais in paises %}
            <tr>
                <td>{{ pais.nombre }}</td>
                <td>{{ pais.continente }}</td>
                <td>{{ "{:,}".format(pais.poblacion) }}</td>
                <td>{{ "{:,}".format(pais.superficie) }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

</body>
</html>
</file>

<file path="utils/filtro_continente.py">
def filtrar_por_continente(lista_paises, continente):
    paises_filtrados = []
    continente_lower = continente.strip().lower()

    for pais in lista_paises:
        if pais['continente'].lower() == continente_lower:
            paises_filtrados.append(pais)

    return paises_filtrados

def gestionar_filtro_continente(lista_paises):
    continente_buscado = input('Ingresa el continente buscado: ')

    if not continente_buscado.strip():
        print('Error: El nombre del continente no puede estar vacío.')
        return
    
    resultados = filtrar_por_continente(lista_paises, continente_buscado)

    if not resultados:
        print(f'No se encuentran países en continente: {continente_buscado}')
        return

    print(f"\n--- Países encontrados en: {continente_buscado.capitalize()} ---")
    print(f"{'Nombre':<30} | {'Población':>15} | {'Superficie (km²)':>18} | {'Continente':<15}")
    print("-" * 85)

    for pais in resultados:
        poblacion_formateada = f"{pais['poblacion']:,}"
        superficie_formateada = f"{pais['superficie']:,}"
        
        print(f"{pais['nombre']:<20} | {poblacion_formateada:>15} | {superficie_formateada:>15} | {pais['continente']:<10}")
        print("-" * 85)
</file>

<file path="utils/filtro_rango_poblacion.py">
def filtrar_por_rango_poblacion(lista_paises):
    bandera_rango :bool = True

    while bandera_rango:
        try:
            opcion_menu = input("Ingrese 1 para filtrar por poblacion, 2 para salir:")
            if opcion_menu == "1":
                try:
                    poblacion_min = int(input("Ingrese la población mínima: "))
                    poblacion_max = int(input("Ingrese la población máxima: "))
                except ValueError:
                    print("Error: Por favor, ingrese valores numéricos válidos para la población.")
                if poblacion_min < 0 or poblacion_max < 0:
                    print("Error: La población no puede ser negativa.")
                elif poblacion_min > poblacion_max:
                    print("Error: La población mínima no puede ser mayor que la máxima.")
                else:
                    paises_filtrados = [pais for pais in lista_paises if poblacion_min <= pais['poblacion'] <= poblacion_max]
                    if paises_filtrados:
                        print(f"\nPaíses con población entre {poblacion_min} y {poblacion_max}:")
                        for pais in paises_filtrados:
                            print(f"- {pais['nombre']}: {pais['poblacion']} habitantes")
                    else:
                        print(f"No se encontraron países con población entre {poblacion_min} y {poblacion_max}.")
            elif opcion_menu == "2":
                print("Saliendo del filtro de población.")
                bandera_rango = False
        except ValueError:
            print("Error: Opción no válida. Por favor, ingrese 1 o 2.")
        except Exception as e:
            print(f"Ocurrió un error inesperado: {e}")
    return
</file>

<file path="utils/filtro_rango_superficie.py">
def filtrar_por_rango_superficie(lista_paises):
    bandera_rango :bool = True

    while bandera_rango:
        try:
            opcion_menu = input("Ingrese 1 para filtrar por superficie, 2 para salir:")
            if opcion_menu == "1":
                try:
                    superficie_min = int(input("Ingrese la superficie mínima: "))
                    superficie_max = int(input("Ingrese la superficie máxima: "))
                except ValueError:
                    print("Error: Por favor, ingrese valores numéricos válidos para la superficie.")
                if superficie_min < 0 or superficie_max < 0:
                    print("Error: La superficie no puede ser negativa.")
                elif superficie_min > superficie_max:
                    print("Error: La superficie mínima no puede ser mayor que la máxima.")
                else:
                    paises_filtrados = [pais for pais in lista_paises if superficie_min <= pais['poblacion'] <= superficie_max]
                    if paises_filtrados:
                        print(f"\nPaíses con superficie entre {superficie_min} y {superficie_max}:")
                        for pais in paises_filtrados:
                            print(f"- {pais['nombre']}: {pais['superficie']} superficie km²")
                    else:
                        print(f"No se encontraron países con superficie entre {superficie_min} y {superficie_max}.")
            elif opcion_menu == "2":
                print("Saliendo del filtro de superficie.")
                bandera_rango = False
        except ValueError:
            print("Error: Opción no válida. Por favor, ingrese 1 o 2.")
        except Exception as e:
            print(f"Ocurrió un error inesperado: {e}")
    return
</file>

<file path="utils/menu.py">
def mostrar_menu():
    print("Menú de opciones")
    print("""
    Gestíon de Datos de países:
        1. Buscar un país por nombre
        2. Filtrar países por continente
        3. Filtrar países por rango de población
        4. Filtrar países por rango de superficie
        5. Ordenar países (por nombre, población o superficie)
        6. Mostrar estadísticas
        7. Salir
    """)
</file>

<file path="utils/ordenar_paises.py">
def ordenar_paises(lista_paises):

    paises_ordenados = sorted(lista_paises, key=lambda pais: pais['nombre'])
    print("\nPaíses ordenados alfabéticamente por nombre:")
    
    for pais in paises_ordenados:
        print(f"- {pais['nombre']}: Población {pais['poblacion']}, Superficie {pais['superficie']} km² ")
    return
</file>

<file path="paises.csv">
nombre,poblacion,superficie,continente
China,1444216107,9596961,Asia
India,1393409038,3287263,Asia
Estados Unidos,332915073,9833520,América
Indonesia,276361783,1904569,Asia
Pakistán,225199937,796095,Asia
Brasil,213993437,8515767,América
Nigeria,211400708,923768,África
Rusia,145912025,17098246,Europa
México,130262216,1972550,América
Japón,126050804,377975,Asia
Egipto,104258327,1002450,África
Alemania,83149300,357022,Europa
Reino Unido,67215293,243610,Europa
Francia,65426179,551695,Europa
Italia,60367477,301340,Europa
Sudáfrica,60041994,1221037,África
Argentina,45376763,2780400,América
España,46745216,505990,Europa
Colombia,51049498,1141748,América
Ucrania,43466819,603500,Europa
Canadá,38067903,9984670,América
Marruecos,37344787,446550,África
Australia,25788215,7692024,Oceanía
Perú,33359418,1285216,América
Chile,19212361,756102,América
Países Bajos,17173981,41850,Europa
Ecuador,17888474,283561,América
Islandia,343353,103000,Europa
Ciudad del Vaticano,825,0,Europa
Uruguay,3485151,176215,América
Finlandia,quinientos,338424,Europa
Nauru,10824,21,Oceanía
Chad,16914985,no_valido,África
Argelia,44700000,2381741,África
</file>

<file path="utils/estadisticas.py">
def mostrar_menu_estadisticas():
    """Imprime en la consola el sub-menú de opciones de estadísticas."""
    print("\n--- SUB-MENÚ DE ESTADÍSTICAS ---")
    print("1. País con Mayor y Menor Población")
    print("2. Promedio de Población y Superficie")
    print("3. Cantidad de Países por Continente")
    print("4. Volver al Menú Principal")
    print("----------------------------------")


def mostrar_extremos_poblacion(lista_paises):
    pais_mas_poblado = max(lista_paises, key=lambda p: p['poblacion'])
    pais_menos_poblado = min(lista_paises, key=lambda p: p['poblacion'])

    print("\nExtremos de Población:")
    print(f"  País más poblado  : {pais_mas_poblado['nombre']:<10} ({pais_mas_poblado['poblacion']:,})")
    print(f"  País menos poblado: {pais_menos_poblado['nombre']:<10} ({pais_menos_poblado['poblacion']:,})")

def mostrar_promedios(lista_paises):
    total_paises = len(lista_paises)
    
    total_poblacion = sum(pais['poblacion'] for pais in lista_paises)
    total_superficie = sum(pais['superficie'] for pais in lista_paises)

    promedio_poblacion = total_poblacion / total_paises if total_paises > 0 else 0
    promedio_superficie = total_superficie / total_paises if total_paises > 0 else 0

    print("\nPromedios Globales:")
    print(f"  Población promedio  : {promedio_poblacion:,.0f} habitantes")
    print(f"  Superficie promedio: {promedio_superficie:,.0f} km²")

def mostrar_conteo_por_continente(lista_paises):
    conteo_continentes = {}
    for pais in lista_paises:
        continente = pais['continente']
        conteo_continentes[continente] = conteo_continentes.get(continente, 0) + 1
    
    print("\nCantidad de Países por Continente:")
    print(f"  {'Continente':<10} | {'Nº de Países':>10}")
    print("-" * 35)
    for continente, conteo in sorted(conteo_continentes.items()):
        print(f"  {continente:<15} | {conteo:>15}")

def gestionar_estadisticas(lista_paises):
    if not lista_paises:
        print("No hay datos de países para calcular estadísticas.")
        return

    while True:
        mostrar_menu_estadisticas()
        opcion = input("Seleccione una opción de estadística: ")

        if opcion == '1':
            mostrar_extremos_poblacion(lista_paises)
        elif opcion == '2':
            mostrar_promedios(lista_paises)
        elif opcion == '3':
            mostrar_conteo_por_continente(lista_paises)
        elif opcion == '4':
            print("Volviendo al menú principal...")
            break
        else:
            print("Opción no válida. Por favor, intente de nuevo.")
</file>

<file path="README.md">
# Trabajo Práctico Integrador (TPI) - Gestión de Datos de Países

**Universidad Tecnológica Nacional (UTN)**
**Tecnicatura Universitaria en Programación**
**Materia:** Programación 1

---

## Descripción del Proyecto:

Este proyecto consiste en una aplicación de consola desarrollada en **Python 3.x** para gestionar información sobre países. El sistema lee un dataset desde un archivo CSV y permite al usuario realizar consultas, aplicar filtros, ordenar los datos y generar estadísticas clave.

El objetivo principal es consolidar los conocimientos adquiridos en la materia, demostrando un uso correcto de:

- Estructuras de datos (Listas de diccionarios).
- Modularización con funciones.
- Manejo de archivos CSV.
- Lógica de programación (filtros, ordenamientos, bucles).
- Buenas prácticas de codificación y documentación.

## Integrantes del Equipo:

| Nombre y Apellido                 |
| :-------------------------------- |
| **Jorge Ramiro Lorenzo Casanova** |
| **Gustavo Adolfo Cortés**         |

## Requisitos Previos:

Para ejecutar este proyecto necesitas tener instalado:

- **Python 3.6** o superior.

## Instalación y Configuración:

Sigue estos pasos para configurar el proyecto en tu entorno local:

1.  **Clonar el repositorio:**
    Abre tu terminal y ejecuta el siguiente comando:

    ```bash
    git clone https://github.com/GCortesGustavo/TPI-Programacion1-Cortes-Lorenzo.git
    ```

2.  **Acceder al directorio del proyecto:**

    ```bash
    cd TPI-Programacion1-Cortes-Lorenzo
    ```

3.  **Verificar el archivo de datos:**
    El archivo `paises.csv` se encuentra en la raíz del proyecto. Este archivo contiene el dataset base necesario para que el programa funcione.

## Instrucciones de Uso:

Para iniciar la aplicación, ejecuta el archivo principal `main.py` desde la terminal estando en la raíz del proyecto:

```bash
python main.py
```
</file>

<file path="utils/buscar_pais.py">
def buscar_pais_por_nombre(lista_paises):
    bandera_busqueda :bool = True
    pais = None
    while bandera_busqueda:
            opcion = input("Ingresa 1 para buscar un país o 2 para salir: ")
            try:
                if opcion == "1":
                    pais_buscado = input("Ingresa el nombre del país o las siglas a buscar: ")
                    pais_buscado = pais_buscado.lower()
                    for pais in lista_paises:
                        try:
                            if pais['nombre'].lower().startswith(pais_buscado):
                                print(f"País encontrado: {pais['nombre']} - Población: {pais['poblacion']} - Superficie: {pais['superficie']} km² - Continente: {pais['continente']}")
                        except ValueError:
                            print(f"el pais no se encontro")
                        except pais == "":
                            print("valor vacio")
                if opcion == "2":
                    bandera_busqueda = False
                    print("Saliendo de la búsqueda.")
            except ValueError:
                print("Opción inválida. Por favor, ingresa 1 o 2.")
</file>

<file path="utils/carga_datos.py">
def cargar_paises_desde_csv(ruta_archivo):

    lista_paises = []
    try:
        with open(ruta_archivo, mode='r', encoding='utf-8') as archivo_csv:
            next(archivo_csv)  # Lee y descarta la línea de encabezado

            for linea in archivo_csv:
                linea_limpia = linea.strip()
                
                if not linea_limpia:
                    continue
                
                objeto = linea_limpia.split(',')
                
                if len(objeto) == 4:
                    try:
                        nombre = objeto[0]
                        poblacion = int(objeto[1])
                        superficie = int(objeto[2])
                        continente = objeto[3]
                        
                        lista_paises.append({
                            'nombre': nombre,
                            'poblacion': poblacion,
                            'superficie': superficie,
                            'continente': continente
                        })
                    except ValueError:
                        print(f"Advertencia: Se omitió la fila para '{objeto[0]}' por datos numéricos inválidos.")
                else:
                    print(f"Advertencia: Se omitió una fila malformada: '{linea_limpia}'")

    except FileNotFoundError:
        print(f"Error: El archivo '{ruta_archivo}' no fue encontrado.")
    except Exception as e:
        print(f"Ocurrió un error inesperado al leer el archivo: {e}")

    return lista_paises
</file>

<file path="main.py">
from utils.buscar_pais import buscar_pais_por_nombre
from utils.carga_datos import cargar_paises_desde_csv
from utils.filtro_continente import gestionar_filtro_continente
from utils.filtro_rango_poblacion import filtrar_por_rango_poblacion
from utils.menu import mostrar_menu
from utils.ordenar_paises import ordenar_paises
from utils.filtro_rango_superficie import filtrar_por_rango_superficie
from utils.estadisticas import gestionar_estadisticas

def main():
    NOMBRE_ARCHIVO_CSV = "paises.csv"

    lista_paises = cargar_paises_desde_csv(NOMBRE_ARCHIVO_CSV)
    
    if not lista_paises:
        print("No se cargaron los datos o el archivo está vacío. El programa se cerrará")
        return

    print(f"\n¡Carga de datos exitosa! Se cargaron {len(lista_paises)} países.")
    print("Ejemplo de datos del primer país:", lista_paises[5])
    
    print("Bienvenido al sistema de gestión de países")

    bandera_menu_princial :bool = True

    while bandera_menu_princial:
        mostrar_menu()

        opcion_menu :str = input("Selecciona una opción del menú: ")

        if opcion_menu == "1":
            print("\nHas elegido la opción 1: Buscar país por nombre")
            buscar_pais_por_nombre(lista_paises)
            pass
        elif opcion_menu == "2":
            print("\nHas elegido la opción 2: Filtrar países por continente")
            gestionar_filtro_continente(lista_paises)
            pass
        elif opcion_menu == "3":
            print("\nHas elegido la opción 3: Filtrar países por población")
            filtrar_por_rango_poblacion(lista_paises)
        elif opcion_menu == "4":
            print("\nHas elegido la opción 4: Filtrar países por superficie")
            filtrar_por_rango_superficie(lista_paises)
        elif opcion_menu == "5":
            print("\nHas elegido la opción 5: Ordenar países")
            ordenar_paises(lista_paises)
        elif opcion_menu == "6":
            print("\nHas elegido la opción 6: Mostrar estadísticas")
            gestionar_estadisticas(lista_paises)
        elif opcion_menu == "7":
            print("\nGracias por utilizar el programa")
            bandera_menu_princial = False
        else:
            print("\nOpción no válida. Ingresa un número del menú.")


if __name__ == "__main__":
    main()
</file>

</files>
